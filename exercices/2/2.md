# Algorithme avancÃ© - Classes et objets

Dans cet exercice, nous allons commencer Ã  manipuler des `classes` et des `objets` pour mieux comprendre la notion de `POO` (`Programmation OrientÃ©e Objet`).

Pour cela, nous allons rÃ©aliser un petit exercice dâ€™algorithmie qui va utiliser les classes et les objets pour nous simplifier le travail.

Dans cet exercice, nous allons incarner un `Robot` nettoyeur de maison :

![](../../images/robot.png)

Pour cela, nous allons rÃ©aliser un script qui va venir nettoyer notre maison de cette maniÃ¨re :

![](./../../images/robot-example.gif)

Tu verras, c'est plutÃ´t "fun" Ã  rÃ©aliser.

Encore une fois, nous allons utiliser des choses que **tu ne connais peut-Ãªtre pas encore**, avec notamment la programmation orientÃ©e objet et les classes en JavaScript.

Cet exercice est une introduction, il faut toujours suivre la mÃªme rÃ¨gle :

> 15 (car les exercices sont plus longs) minutes par partie, maximum, puis regarder la vidÃ©o solution.

Chaque vidÃ©o solution va contenir la thÃ©orie nÃ©cessaire pour effectuer les exercices.

### Partie 1

Dans cette premiÃ¨re partie, nous allons faire en sorte de pouvoir "log" notre Maison dans la console, avec toutes les diffÃ©rentes piÃ¨ces, ainsi qu'avec l'emplacement du robot.

Nous voudrons aussi pouvoir log la batterie restante de notre robot.

```txt
ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
ğŸ¤–ğŸ§¼ğŸ’©ğŸ’©ğŸ§¼
ğŸ§¼ğŸ’©ğŸ§¼ğŸ’©ğŸ’©
ğŸ§¼ğŸ§¼ğŸ’©ğŸ’©ğŸ’©
ğŸ’©ğŸ’©ğŸ’©ğŸ§¼ğŸ§¼
ğŸ’©ğŸ’©ğŸ’©ğŸ’©ğŸ’©
```

Voici le rÃ©sultat final de la console.

Pour faire cela, il va falloir faire les choses suivantes :

- CrÃ©er une `class` Robot qui possÃ¨de une propriÃ©tÃ© `position` et `battery`, ainsi qu'une mÃ©thode `logBattery`

  - `position` correspond Ã  `[0, 0]`, l'emplacement de dÃ©part du robot
  - `battery` correspond Ã  `100`, la batterie de dÃ©part du robot
  - la mÃ©thode `logBattery` va afficher 10 carrÃ©s, rouges ("ğŸŸ¥") ou verts ("ğŸŸ©"), en fonction de la batterie (60% = 6 carrÃ©s verts et 4 carrÃ©s rouges)

- CrÃ©er une `class` PiÃ¨ce qui correspond Ã  une piÃ¨ce de notre maison.

  - Cette piÃ¨ce a un Ã©tat qui pourra Ãªtre `clean`, `dirty` ou `clean_by_robot` !
  - Elle aura une mÃ©thode `getEmoji` qui retournera l'emoji correspondant Ã  son Ã©tat

- CrÃ©er une `class` House qui correspond Ã  notre maison, avec comme propriÃ©tÃ© `layout` et `robot`
  - `layout` correspond Ã  un tableau de tableaux qui reprÃ©sente notre maison
  - `robot` correspond Ã  notre robot

### Comment crÃ©er des classes ?

Les `classes` sont des sortes de modÃ¨les pour crÃ©er des objets et les objets tu les connais dÃ©jÃ .

Quand on fait `"test".toUpperCase()`, on appelle la **mÃ©thode** `toUpperCase` de la classe `String`.

Les classes `String`, `Boolean` ou `Array` sont des classes qui sont dÃ©jÃ  prÃ©sentes dans JavaScript, mais il est possible de crÃ©er nos propres `classes`.

Pour crÃ©er une classe, comme celle du robot, nous allons utiliser le mot clÃ© `class` puis `constructor`

```js
class Robot {
  constructor() {
    // ...
  }
}
```

Le constructeur est la mÃ©thode qui va Ãªtre appelÃ©e lors de **la crÃ©ation** de notre robot, c'est ici que nous allons initialiser les propriÃ©tÃ©s de notre robot.

```js
class Robot {
  constructor() {
    this.battery = 100;
    // ...
  }
}
```

On pourra ensuite ajouter des mÃ©thodes comme `logBattery` :

```js
class Robot {
  constructor() {
    this.battery = 100;
    // ...
  }

  logBattery() {
    // On peut utiliser la mÃ©thode `this.battery` directement dans la mÃ©thode
    this.battery;
    // ...
  }
}
```

Je te laisse essayer, les Ã©mojis sont lÃ  pour t'aider.

âš ï¸ Je sais qu'il y a beaucoup de choses Ã  faire et que ce n'est pas facile, accroche-toi et n'hÃ©site pas Ã  regarder la vidÃ©o solution.

## Partie 2

Dans cette partie, on va faire en sorte que notre robot puisse se dÃ©placer dans notre maison.

#### On va crÃ©er 3 mÃ©thodes pour notre robot :

- `checkBattery`

Cette mÃ©thode va vÃ©rifier l'Ã©tat de la batterie. Si celle-ci est Ã©gale Ã  0, on va retourner Ã  la case `[0,0]` qui sera notre sorte de "base" pour recharger notre robot.

AprÃ¨s cela, on va dÃ©finir la batterie Ã  100 et retourner `true` pour indiquer que nous avons bien rechargÃ© notre robot.

Dans le cas contraire, on retourne `false`, pour indiquer que nous n'avons pas eu besoin de charger notre robot.

Affiche des petites phrases dans la console pour savoir si nous avons rechargÃ© notre robot ou non.

- `move`

Une mÃ©thode qui permet de dÃ©placer le robot de 1 dans la direction donnÃ©e en paramÃ¨tre.

Cette mÃ©thode prend `x` et `y` en paramÃ¨tres.

Tu vas commencer par vÃ©rifier l'Ã©tat de la batterie, si la mÃ©thode `checkBattery` te renvoie `true`, tu dois arrÃªter le mouvement car nous venons de recharger le robot.

Ensuite, il faut vÃ©rifier que `x` et `y` sont uniquement Ã©gaux Ã  `1` ou `-1`, sinon on retourne `false`, car on ne peut pas se dÃ©placer dans cette direction.

Pour cela, tu peux vÃ©rifier la **valeur absolue** de `x` et `y` avec `Math.abs(x)` et `Math.abs(y)` qui ne doit pas Ãªtre supÃ©rieure Ã  1.

Finalement, si tout est OK, tu vas dÃ©placer le robot en `[x, y]` et tu vas diminuer la batterie de 1 pour le coÃ»t du mouvement.

- `clean(house)`

La mÃ©thode `clean` prend en paramÃ¨tre la maison.

Cette mÃ©thode va faire la mÃªme vÃ©rification que `move` pour la batterie.

Ensuite, on diminue la batterie de 0.5 pour le coÃ»t du nettoyage.

Puis, on va appeler la mÃ©thode `house.clean(this.position)` pour nettoyer la case oÃ¹ se trouve actuellement notre robot.

#### On va crÃ©er 1 mÃ©thode pour notre piÃ¨ce

- `clean`

La mÃ©thode `clean` va modifier la valeur de `state` de la piÃ¨ce en `clean_by_robot`, si la valeur actuelle est `dirty`.

#### On va crÃ©er 1 mÃ©thode pour notre maison

- `clean(position)`

On va venir rÃ©cupÃ©rer la piÃ¨ce Ã  la bonne position (x et y) et on va appeler la mÃ©thode `clean` de la piÃ¨ce.

ğŸ’¡ `this.layout[position[0]][position[1]].clean();`

### Test

Pour tester que tout fonctionne, dans la fonction `start` tu peux simuler des mouvements.

Par exemple, tu peux crÃ©er une fonction qui dÃ©place le robot en mode "serpent", de droite Ã  gauche et de gauche Ã  droite, en appelant toujours `clean` sur chaque position.

Voici un petit code que tu peux mettre Ã  la fin de ta fonction `play`, juste pour vÃ©rifier que tout fonctionne bien :

```js
let direction = 1;

for (let i = 0; i < houseSize[0]; i++) {
  for (let j = 0; j < houseSize[1]; j++) {
    console.clear();

    robot.logBattery();
    house.logLayout();
    robot.move(direction, 0);
    robot.clean(house);
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
  robot.move(0, 1);
  direction = direction === 1 ? -1 : 1;
  robot.clean(house);
}
```

âš ï¸ Ce code ne fonctionne pas bien, il est juste lÃ  pour te montrer que tout le code que tu as produit fonctionne correctement. Tu devrais voir le robot bouger et faire un peu n'importe quoi, mais on va s'occuper de la logique dans la partie 4.

### Partie 3

Deux petites mÃ©thodes avant le grand final de notre exercice.

Afin de rÃ©aliser la suite, on aura besoin de 2 autres mÃ©thodes :

#### PiÃ¨ce

On va crÃ©er des `getter` pour notre piÃ¨ce. Les `getter` sont des sortes de mÃ©thodes qui ne prennent aucun paramÃ¨tre.

La grande diffÃ©rence, c'est la maniÃ¨re de les appeler.

Pour notre `PiÃ¨ce`, on va crÃ©er un `getter` pour `isDirty` et `isClean`.

Voici Ã  quoi ressemble le `isClean` :

```js
class Piece {
  // ...

  get isDirty() {
    return this.state === 'dirty';
  }
}

const piece = new Piece('dirty');

console.log(piece.isDirty); // true
```

Comme tu le vois, quand je fais `piece.isDirty`, je n'utilise Ã  aucun moment de parenthÃ¨se `()`.

J'appelle juste ma propriÃ©tÃ©. C'est ce qu'on appelle une "propriÃ©tÃ© calculÃ©e".

CrÃ©e une deuxiÃ¨me propriÃ©tÃ© calculÃ©e `isClean` qui va renvoyer `true` si la piÃ¨ce est propre (le state est Ã©gal Ã  `clean` ou `clean_by_robot`).

#### House

- `isAllClean`

Cette mÃ©thode va renvoyer `true` uniquement si **toutes les piÃ¨ces** de la maison sont propres.

Ã€ toi de jouer !

## Partie 4

C'est ici que tu vas t'arracher les cheveux.

C'est ici que tout devient compliquÃ©.

On a jouÃ© aux Lego, on vient de prÃ©parer toutes nos piÃ¨ces et, maintenant, il faut toutes les assembler pour crÃ©er notre application.

Pour Ã§a, on va encore crÃ©er des mÃ©thodes.

### House

- `nearestDirtyPiece`

Cette mÃ©thode va renvoyer la position de la piÃ¨ce la plus proche du robot qui est sale.

Je te laisse essayer de la crÃ©er et tu trouveras dans le fichier `tips.md` plein de conseils pour t'aider dans le titre `Tips nearestDirtyPiece` !

### Robots

- `doWork`

C'est la mÃ©thode qui va gÃ©rer toute la logique pour une action.

Cette mÃ©thode va devoir :

- RÃ©cupÃ©rer la piÃ¨ce la plus proche
- Trouver le delta (la diffÃ©rence) entre la position du robot et la position de la piÃ¨ce la plus proche
  - Pour `deltaX` et `deltaY`
- Si la diffÃ©rence est 0, c'est qu'on est sur une piÃ¨ce sale = nettoyer
- Si la diffÃ©rence est positive, on va dÃ©placer le robot dans la bonne direction

N'oublie pas que tu peux dÃ©placer uniquement le robot d'une case Ã  la fois.

Tu trouveras dans le fichier `tips.md` plein d'aide sous le titre `Tips doWork`

## Conclusion

Suivant ton niveau, cet exercice Ã©tait dÃ©stabilisant. Il fait intervenir de la POO que tu ne connais peut-Ãªtre pas, ainsi que de l'algorithmie.

Ne t'en fais pas, on va tout comprendre dans les exercices qui suivent.
