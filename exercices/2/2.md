# Algortime avancÃ©es - Class et objet

Dans cette exercice, on va commencer Ã  manipuler des `class` et des `objet` pour mieux comprendre la notion de `POO` (`Programmation OrientÃ© Objet`).

Pour Ã§a, on va faire un petit exercice dâ€™algorithmie qui va utiliser les class et les objets pour nous simplifier le travail.

Dans cette exercice on va incarnÃ©es un `Robot` nettoyeur de maison :

![](../../images/robot.png)

Pour Ã§a, on va rÃ©aliser un script qui va venir nettoyer notre maison de cette maniÃ¨re :

![](./../../images/robot-example.gif)

Tu verra, c'est plutÃ´t "fun" Ã  rÃ©aliser.

Encore une fois on va utiliser des choses que **tu ne connaÃ®s peut-Ãªtre pas encore** avec notamment la programmation orientÃ© objet et les classes en JavaScript.

Cette exercice est une introduction, il faut toujours suivre la mÃªme rÃ¨gles :

> 15 (car les exercices sont plus long) minutes par parties maximum puis regarder la vidÃ©o solution.

Chaque vidÃ©o solution va contenir la thÃ©orie nÃ©cessaire pour effectuer les exercices.

### Part 1

Dans cette premiÃ¨re parties on va faire en sortes de pouvoir "log" notre Maison dans la console avec toutes les diffÃ©rentes piÃ¨ces ainsi qu'avec l'emplacement du robot.

On voudra aussi pouvoir log la batterie restante de notre robot.

```txt
ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©
ğŸ¤–ğŸ§¼ğŸ’©ğŸ’©ğŸ§¼
ğŸ§¼ğŸ’©ğŸ§¼ğŸ’©ğŸ’©
ğŸ§¼ğŸ§¼ğŸ’©ğŸ’©ğŸ’©
ğŸ’©ğŸ’©ğŸ’©ğŸ§¼ğŸ§¼
ğŸ’©ğŸ’©ğŸ’©ğŸ’©ğŸ’©
```

Voici le rÃ©sultat finale de la console.

Pour faire Ã§a il va falloir faire les choses suivantes :

- CrÃ©er une `class` Robot qui possÃ¨de une propriÃ©tÃ©s `position` et `battery` ainsi qu'une mÃ©thode `logBattery`

  - `position` correspond Ã  `[0, 0]`, l'emplacement de dÃ©part du robot
  - `battery` correspond Ã  `100`, la batterie de dÃ©part du robot
  - la mÃ©thode `logBattery` va affichÃ© un 10 carrÃ©, rouge ("ğŸŸ¥") ou vert ("ğŸŸ©"), en fonction de la battery (60% = 6 carrÃ© vert et 4 carrÃ© rouge)

- CrÃ©er une `class` Piece qui correspond Ã  une piÃ¨ce de notre maison.

  - Cette piÃ¨ce Ã  un state qui pourra Ãªtre soit `clean`, `dirty` ou `clean_by_robot` !
  - Elle aura une mÃ©thode `getEmoji` qui retournera l'emoji correspondant Ã  son state

- CrÃ©er une `class` House qui correspond Ã  notre maison avec comme propriÃ©tÃ© `layout` et `robot`
  - `layout` correspond Ã  un tableau de tableau qui reprÃ©sente notre maison
  - `robot` correspond Ã  notre robot

### Comment crÃ©er des class ?

Les `class` sont des sortes de modÃ¨le pour crÃ©er des objets et les objets tu les connÃ¢is dÃ©jÃ .

Quand on fait `"test".toUpperCase()` on appel la **mÃ©thode** `toUpperCase` de la class `String`.

Les classes `String`, `Boolean` ou `Array` sont des classes qui sont dÃ©jÃ  prÃ©sente dans JavaScript mais il est possible de crÃ©er nos propres `class`.

Pour crÃ©er une class, comme celle du robot on va utiliser le mot clÃ© `class` puis `constructor`

```js
class Robot {
  constructor() {
    // ...
  }
}
```

Le constructeur est la mÃ©thode qui va Ãªtre appelÃ© lors de **la crÃ©ation** de notre robot, c'est ici qu'on va initialiser les propriÃ©tÃ©s de notre robot.

```js
class Robot {
  constructor() {
    this.battery = 100;
    // ...
  }
}
```

On pourra ensuite ajoutÃ© des mÃ©thodes comme `logBattery` :

```js
class Robot {
  constructor() {
    this.battery = 100;
    // ...
  }

  logBattery() {
    // On peut utiliser la mÃ©thode `this.battery` directement dans la mÃ©thode
    this.battery;
    // ...
  }
}
```

Je te laisse jouer, les Ã©mojis sont lÃ  pour t'aider.

âš ï¸ Je sais qu'il y a beaucoup de chose Ã  faire et que c'est pas facile, accroche toi et n'hÃ©site pas Ã  regarder la vidÃ©o solution.

## Partie 2

Dans cette partie on va faire en sortes que notre robot puisse se dÃ©placer dans notre maison.

#### On va crÃ©er 3 mÃ©thodes pour notre robot :

- `checkBattery`

Cette mÃ©thode va vÃ©rifier l'Ã©tat de la batterie. Si celle-ci est Ã©gal Ã  0, on va retourner Ã  la case `[0,0]` qui sera notre sorte de "base" pour recharger notre robot.

AprÃ¨s ceci, on va dÃ©finir la batterie Ã  100 et retourner `true` comme quoi on a bien rechargÃ© notre robot.

Dans le cas contraire on retourne `false` comme quoi on a pas eu besoin de chargÃ© notre robot.

Affiche des petites phrases dans la console pour savoir si on a rechargÃ© notre robot ou non.

- `move`

Une mÃ©thode qui permet de bouger robot de 1 dans la direction donnÃ©e en paramÃ¨tre.

Cette mÃ©thode prends `x` et `y` en paramÃ¨tre.

Tu vas commencer par vÃ©rifier l'Ã©tat de la batterie, si la mÃ©thode `checkBattery` te renvoie `true` tu dois arrÃªter le mouvement car on vient de recharger le robot.

Ensuite il faut vÃ©rifier que `x` et `y` sont uniquement Ã©gal Ã  `1` ou `-1` sinon on retourne `false` car on ne peut pas bouger dans cette direction.

Pour Ã§a tu peux vÃ©rifier la **valeur absolue** de `x` et `y` avec `Math.abs(x)` et `Math.abs(y)` qui ne doit pas Ãªtre supÃ©rieur Ã  1.

Finalement si tout est OK, tu vas dÃ©placer le robot en `[x, y]` et tu vas diminuer la batterie de 1 pour le coups du mouvement.

- `clean(house)`

La mÃ©thode `clean` prends en paramÃ¨tre la maison.

Cette mÃ©thode va faire la mÃªme vÃ©rification que `move` pour la batterie.

Ensuite, on diminue la batterie de 0.5 pour le coup du nettoyage.

Puis on v appeler la mÃ©thode `house.clean(this.position)` pour nettoyer la case ou est actuellement notre robot.

#### On va crÃ©er 1 mÃ©thode pour notre piÃ¨ce

- `clean`

La mÃ©thode `clean` va modifier la valeur de `state` de la piÃ¨ce en `clean_by_robot` si la valeur actuelle est `dirty`.

#### On va crÃ©er 1 mÃ©thode pour notre maison

- `clean(position)`

On va venir rÃ©cupÃ©rer la piÃ¨ce Ã  la bonne position (x et y) et on va appeler la mÃ©thode `clean` de la piÃ¨ce.

ğŸ’¡ `this.layout[position[0]][position[1]].clean();`

### Test

Pour tester que tout fonctionne, dans la function `start` tu peux simuler des mouvements.

Par exemple tu peux crÃ©er une function qui bouge le robot en mode "serpent" de droite Ã  gauche et de gauche Ã  droite en appelant toujours `clean` sur chaque position.

VoilÃ  un petit code que tu peux mettre Ã  la fin de ta function `play` juste pour vÃ©rifier que tout fonctionne bien :

```js
let direction = 1;

for (let i = 0; i < houseSize[0]; i++) {
  for (let j = 0; j < houseSize[1]; j++) {
    console.clear();

    robot.logBattery();
    house.logLayout();
    robot.move(direction, 0);
    robot.clean(house);
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
  robot.move(0, 1);
  direction = direction === 1 ? -1 : 1;
  robot.clean(house);
}
```

âš ï¸ Ce code ne fonctionne pas bien, il est juste lÃ  pour te montrer que tout le code que tu as produit fonctionne correctement. Tu devrais voir le robot bouge et faire un peu n'importe quoi mais on vas s'occuper de la logique dans la partie 4.

### Partie 3

Deux petites mÃ©thodes avant le grand finale de notre exerice.

Afin de rÃ©aliser la suite, on aura besoin de 2 autres mÃ©thodes :

#### Piece

On va crÃ©er des `getter` pour notre piÃ¨ce. Les `getter` sont des sortes de mÃ©thode qui ne prennes aucun paramÃ¨tre.

La grande diffÃ©rence c'est la maniÃ¨re de les appelÃ©s.

Pour notre `Piece` on vas crÃ©er un `getter` pour `isDirty` et `isClean`.

Voici Ã  quoi ressemble le `isClean` :

```js
class Piece {
  // ...

  get isDirty() {
    return this.state === 'dirty';
  }
}

const piece = new Piece('dirty');

console.log(piece.isDirty); // true
```

Comme tu le vois, quand je fais `piece.isDirty` je n'utilises Ã  aucun moment de parenthÃ¨se `()`.

J'appel juste ma propriÃ©tÃ©s. C'est ce qu'on appels une "propriÃ©tÃ©s calculÃ©e".

CrÃ©er une deuxiÃ¨me propriÃ©tÃ© calculÃ©e `isClean` qui va renvoyer `true` si la piÃ¨ce est propre (le state est Ã©gal Ã  `clean` ou `clean_by_robot`).

#### House

- `isAllClean`

Cette mÃ©thode va renvoyer `true` uniquement si **toute les piÃ¨ces** de la maison sont propre.

Ã€ toi de jouer !

## Partie 4

C'est ici que tu vas t'arracher les cheveux.

C'est ici que tout deviens compliquÃ©.

On a jouer au Lego, on vient de prÃ©parer toutes nos piÃ¨ces et maintenant il faut toutes les assemblers pour crÃ©er notre application.

Pour Ã§a on va encore crÃ©er des mÃ©thodes.

### House

- `nearestDirtyPiece`

Cette mÃ©thode va renvoyer la position de la piÃ¨ce la plus proche du robot qui est sale.

Je te laisse essayer de la crÃ©er et tu trouveras dans le fichier `tips.md` pleins de tips pour t'aider dans le titre `Tips nearestDirtyPiece` !

### Robots

- `doWork`

C'est la mÃ©thode qui va gÃ©rer toute la logique pour une action.

Cette mÃ©thode va devoir :

- RÃ©cupÃ©rer la piÃ¨ce la plus proche
- Trouver le delta (la diffÃ©rence) entre la position du robot et la position de la piÃ¨ce la plus proche
  - Pour `deltaX` et `deltaY`
- Si la diffÃ©rence est 0, c'est qu'on est sur une piÃ¨ce sale = nettoyer
- Si la diffÃ©rence est position, on va dÃ©placer le robot dans la bonne direction

N'oublie pas que tu peux dÃ©placer uniquement le robot de 1 case Ã  la fois.

Tu trouveras dans le fichier `tips.md` pleins d'aide sous le titre `Tips doWork`

## Conclusion

Suivant ton niveau, cette exercice Ã©tait dÃ©stabilisant. Il fait intervenir de la POO que tu connaÃ®s peut-Ãªtre pas ainsi que de l'alogritmie.

Ne t'en fais pas, on va tout comprendre dans les exercice qui suivent.
